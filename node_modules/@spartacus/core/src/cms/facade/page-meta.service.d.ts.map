{"version":3,"file":"page-meta.service.d.ts","sources":["page-meta.service.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA","sourcesContent":["import { Observable } from 'rxjs';\r\nimport { Page, PageMeta } from '../model/page.model';\r\nimport { PageMetaResolver } from '../page/page-meta.resolver';\r\nimport { CmsService } from './cms.service';\r\nexport declare class PageMetaService {\r\n    protected resolvers: PageMetaResolver[];\r\n    protected cms: CmsService;\r\n    constructor(resolvers: PageMetaResolver[], cms: CmsService);\r\n    /**\r\n     * The list of resolver interfaces will be evaluated for the pageResolvers.\r\n     *\r\n     * TOOD: optimize browser vs SSR resolvers; image, robots and description\r\n     *       aren't needed during browsing.\r\n     * TODO: we can make the list of resolver types configurable\r\n     */\r\n    protected resolverMethods: {\r\n        [key: string]: string;\r\n    };\r\n    getMeta(): Observable<PageMeta>;\r\n    /**\r\n     * If a `PageResolver` has implemented a resolver interface, the resolved data\r\n     * is merged into the `PageMeta` object.\r\n     * @param metaResolver\r\n     */\r\n    protected resolve(metaResolver: PageMetaResolver): Observable<PageMeta>;\r\n    /**\r\n     * Return the resolver with the best match, based on a score\r\n     * generated by the resolver.\r\n     *\r\n     * Resolvers match by default on `PageType` and `page.template`.\r\n     */\r\n    protected getMetaResolver(page: Page): PageMetaResolver;\r\n}\r\n"]}
{"version":3,"file":"product.service.d.ts","sources":["product.service.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA","sourcesContent":["import { Store } from '@ngrx/store';\r\nimport { Observable } from 'rxjs';\r\nimport { Product } from '../../model/product.model';\r\nimport { StateWithProduct } from '../store/product-state';\r\nimport { ProductLoadingService } from '../services/product-loading.service';\r\nimport { ProductScope } from '../model/product-scope';\r\nexport declare class ProductService {\r\n    protected store: Store<StateWithProduct>;\r\n    protected productLoading: ProductLoadingService;\r\n    constructor(store: Store<StateWithProduct>, productLoading: ProductLoadingService);\r\n    /**\r\n     * Returns the product observable. The product will be loaded\r\n     * whenever there's no value observed.\r\n     *\r\n     * The underlying product loader ensures that the product is\r\n     * only loaded once, even in case of parallel observers.\r\n     *\r\n     * You should provide product data scope you are interested in to not load all\r\n     * the data if not needed. You can provide more than one scope.\r\n     *\r\n     * @param productCode Product code to load\r\n     * @param scopes Scope or scopes of the product data\r\n     */\r\n    get(productCode: string, scopes?: (ProductScope | string)[] | ProductScope | string): Observable<Product>;\r\n    /**\r\n     * Returns boolean observable for product's loading state\r\n     */\r\n    isLoading(productCode: string, scope?: ProductScope | string): Observable<boolean>;\r\n    /**\r\n     * Returns boolean observable for product's load success state\r\n     */\r\n    isSuccess(productCode: string, scope?: ProductScope | string): Observable<boolean>;\r\n    /**\r\n     * Returns boolean observable for product's load error state\r\n     */\r\n    hasError(productCode: string, scope?: ProductScope | string): Observable<boolean>;\r\n    /**\r\n     * Reloads the product. The product is loaded implicetly\r\n     * whenever selected by the `get`, but in some cases an\r\n     * explicit reload might be needed.\r\n     */\r\n    reload(productCode: string, scope?: ProductScope | string): void;\r\n}\r\n"]}
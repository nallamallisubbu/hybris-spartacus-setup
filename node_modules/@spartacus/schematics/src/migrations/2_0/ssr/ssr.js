"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const schematics_1 = require("@angular-devkit/schematics");
const core_1 = require("@angular-devkit/core");
const ts = __importStar(require("typescript"));
const ast_utils_1 = require("@schematics/angular/utility/ast-utils");
const dependencies_1 = require("@schematics/angular/utility/dependencies");
const file_utils_1 = require("../../../shared/utils/file-utils");
const constants_1 = require("../../../shared/constants");
const workspace_utils_1 = require("../../../shared/utils/workspace-utils");
function migrate() {
    return (host) => __awaiter(this, void 0, void 0, function* () {
        return (yield checkIfSSRIsUsed(host))
            ? schematics_1.chain([
                backupExistingFiles(),
                overwriteServerTsFile(),
                modifyPackageJsonScripts(),
                removeImportsInMainServerFile(),
                removeMapLoaderModule(),
                updateAngularJsonFile(),
            ])
            : schematics_1.noop();
    });
}
exports.migrate = migrate;
function backupExistingFiles() {
    return (tree, context) => {
        context.logger.info('Backing up old server.ts and webpack.server.config.js files.');
        const serverPath = '/server.ts';
        const webpackPath = '/webpack.server.config.js';
        const webpackBuffer = tree.read(webpackPath);
        if (webpackBuffer === null) {
            throw new schematics_1.SchematicsException('Could not find webpack.server.config.js file');
        }
        tree.rename(serverPath, './server.ts.bak');
        tree.rename(webpackPath, './webpack.server.config.js.bak');
    };
}
exports.backupExistingFiles = backupExistingFiles;
function overwriteServerTsFile() {
    return (tree, context) => __awaiter(this, void 0, void 0, function* () {
        context.logger.info('Creating new server.ts file.');
        const projectName = workspace_utils_1.getDefaultProjectNameFromWorkspace(tree);
        return schematics_1.chain([
            schematics_1.mergeWith(schematics_1.apply(schematics_1.url('./files'), [
                schematics_1.template(Object.assign(Object.assign(Object.assign(Object.assign({}, core_1.strings), { typescriptExt: 'ts' }), {}), { browserDistDirectory: `dist/${projectName}/browser` })),
                schematics_1.move('.'),
            ])),
        ]);
    });
}
exports.overwriteServerTsFile = overwriteServerTsFile;
function modifyPackageJsonScripts() {
    return (tree, context) => __awaiter(this, void 0, void 0, function* () {
        context.logger.info('Updating package.json scripts');
        const pkgPath = '/package.json';
        const buffer = tree.read(pkgPath);
        if (!buffer) {
            throw new schematics_1.SchematicsException('Could not find package.json');
        }
        const packageJson = JSON.parse(buffer.toString(constants_1.UTF_8));
        const scripts = [
            'compile:server',
            'build:ssr',
            'serve:ssr',
            'build:client-and-server-bundles',
        ];
        const packagesToAddOrUpdate = [
            {
                type: dependencies_1.NodeDependencyType.Default,
                version: constants_1.ANGULAR_UNIVERSAL_EXPRESS_VERSION,
                name: '@nguniversal/express-engine',
                overwrite: true,
            },
            {
                type: dependencies_1.NodeDependencyType.Dev,
                version: constants_1.ANGULAR_UNIVERSAL_BUILDERS,
                name: '@nguniversal/builders',
                overwrite: true,
            },
        ];
        const projectName = workspace_utils_1.getDefaultProjectNameFromWorkspace(tree);
        scripts.forEach((key) => {
            const keyBackup = `${key}_bak`;
            const scriptValue = packageJson.scripts[key];
            if (scriptValue && !packageJson.scripts[keyBackup]) {
                packageJson.scripts[keyBackup] = scriptValue;
                packageJson.scripts[key] = undefined;
            }
        });
        packageJson.scripts['dev:ssr'] = `ng run ${projectName}:serve-ssr`;
        packageJson.scripts['serve:ssr'] = `node dist/${projectName}/server/main.js`;
        packageJson.scripts['build:ssr'] = `ng build --prod && ng run ${projectName}:server:production`;
        packageJson.scripts['prerender'] = `ng run ${projectName}:prerender`;
        tree.overwrite(pkgPath, JSON.stringify(packageJson, null, 2));
        dependencies_1.removePackageJsonDependency(tree, '@nguniversal/module-map-ngfactory-loader');
        packagesToAddOrUpdate.forEach((dep) => {
            dependencies_1.addPackageJsonDependency(tree, dep);
        });
    });
}
exports.modifyPackageJsonScripts = modifyPackageJsonScripts;
function removeImportsInMainServerFile() {
    return (tree, context) => {
        context.logger.info('Removing unnecessary ngExpressEngine import after migration');
        const mainServerTsPath = 'src/main.server.ts';
        const buffer = tree.read(mainServerTsPath);
        if (!buffer) {
            throw new schematics_1.SchematicsException('Could not find main.server.ts');
        }
        const recorder = tree.beginUpdate(mainServerTsPath);
        const mainServerTsSourceFile = createSourceFileWithStrippedBOM(tree, mainServerTsPath);
        removeFullLineFromExportDeclarationsByModuleName(mainServerTsSourceFile, recorder, '@nguniversal/module-map-ngfactory-loader');
        removeFullLineFromImportDeclarationsByModuleName(mainServerTsSourceFile, recorder, '@nguniversal/express-engine');
        removeFullLineFromImportDeclarationsByModuleName(mainServerTsSourceFile, recorder, '@spartacus/core');
        removeFullLineWithCallExpressionByModuleName(mainServerTsSourceFile, recorder, 'NgExpressEngineDecorator.get');
        tree.commitUpdate(recorder);
    };
}
exports.removeImportsInMainServerFile = removeImportsInMainServerFile;
function removeMapLoaderModule() {
    return (tree, context) => {
        context.logger.info('Removing MapLoaderModule import');
        const mapLoaderModuleTsPath = 'src/app/app.server.module.ts';
        if (!tree.read(mapLoaderModuleTsPath)) {
            throw new schematics_1.SchematicsException('Could not find app.server.module.ts');
        }
        const recorder = tree.beginUpdate(mapLoaderModuleTsPath);
        const moduleMapLoaderToBeRemoved = '@nguniversal/module-map-ngfactory-loader';
        const appServerModuleSourceFile = createSourceFileWithStrippedBOM(tree, mapLoaderModuleTsPath);
        const printer = ts.createPrinter();
        removeFullLineFromImportDeclarationsByModuleName(appServerModuleSourceFile, recorder, moduleMapLoaderToBeRemoved);
        ast_utils_1.getDecoratorMetadata(appServerModuleSourceFile, 'NgModule', constants_1.ANGULAR_CORE).forEach((metadata) => {
            const matchingProperties = ast_utils_1.getMetadataField(metadata, 'imports');
            if (!matchingProperties) {
                return;
            }
            const assignment = matchingProperties[0];
            if (!ts.isArrayLiteralExpression(assignment.initializer)) {
                return;
            }
            const arrayLiteral = assignment.initializer;
            const newImports = arrayLiteral.elements.filter((n) => !(ts.isIdentifier(n) && n.text === 'ModuleMapLoaderModule'));
            if (arrayLiteral.elements.length !== newImports.length) {
                const newImportsText = printer.printNode(ts.EmitHint.Unspecified, ts.updateArrayLiteral(arrayLiteral, newImports), appServerModuleSourceFile);
                const index = arrayLiteral.getStart();
                const length = arrayLiteral.getWidth();
                recorder.remove(index, length).insertLeft(index, newImportsText);
            }
        });
        tree.commitUpdate(recorder);
    };
}
exports.removeMapLoaderModule = removeMapLoaderModule;
function updateAngularJsonFile() {
    return (tree, context) => __awaiter(this, void 0, void 0, function* () {
        context.logger.info('Updating angular.json builds dist configuration');
        const projectName = workspace_utils_1.getDefaultProjectNameFromWorkspace(tree);
        const buffer = tree.read('angular.json');
        if (!buffer) {
            throw new schematics_1.SchematicsException('Could not find angular.json');
        }
        const angularJson = JSON.parse(buffer.toString(constants_1.UTF_8));
        angularJson.projects[projectName].architect.build.options['outputPath'] = `dist/${projectName}/browser`;
        angularJson.projects[projectName].architect['server'] = {
            builder: '@angular-devkit/build-angular:server',
            options: {
                outputPath: `dist/${projectName}/server`,
                main: 'server.ts',
                tsConfig: 'tsconfig.server.json',
            },
            configurations: {
                production: {
                    outputHashing: 'media',
                    fileReplacements: [
                        {
                            replace: 'src/environments/environment.ts',
                            with: 'src/environments/environment.prod.ts',
                        },
                    ],
                    sourceMap: false,
                    optimization: true,
                },
            },
        };
        tree.overwrite('angular.json', JSON.stringify(angularJson, null, 2));
    });
}
exports.updateAngularJsonFile = updateAngularJsonFile;
function checkIfSSRIsUsed(tree) {
    return __awaiter(this, void 0, void 0, function* () {
        const projectName = workspace_utils_1.getDefaultProjectNameFromWorkspace(tree);
        const buffer = tree.read('angular.json');
        if (!buffer) {
            throw new schematics_1.SchematicsException('Could not find angular.json');
        }
        const angularFileBuffer = buffer.toString(constants_1.UTF_8);
        const angularJson = JSON.parse(angularFileBuffer);
        const isServerConfiguration = !!angularJson.projects[projectName].architect['server'];
        const serverFilePath = file_utils_1.getPathResultsForFile(tree, 'server.ts', '/')[0];
        const serverBuffer = tree.read(serverFilePath);
        if (!serverBuffer) {
            return false;
        }
        const serverFileBuffer = serverBuffer.toString(constants_1.UTF_8);
        const isServerSideAvailable = serverFileBuffer && !!serverFileBuffer.length;
        return !!(isServerConfiguration && isServerSideAvailable);
    });
}
function createSourceFileWithStrippedBOM(tree, path) {
    const buffer = tree.read(path);
    if (!buffer) {
        throw new schematics_1.SchematicsException(`No tree found for ${path}.`);
    }
    // Strip BOM as otherwise TSC methods (Ex: getWidth) will return an offset which
    // which breaks the CLI UpdateRecorder.
    // See: https://github.com/angular/angular/pull/30719
    return ts.createSourceFile(path, buffer.toString(constants_1.UTF_8).replace(/^\uFEFF/, ''), ts.ScriptTarget.Latest, true);
}
function removeFullLineFromImportDeclarationsByModuleName(sourceTsFile, treeRecorder, moduleNameString) {
    sourceTsFile.statements
        .filter((s) => ts.isImportDeclaration(s) &&
        s.moduleSpecifier &&
        ts.isStringLiteral(s.moduleSpecifier) &&
        s.moduleSpecifier.text === moduleNameString)
        .forEach((node) => {
        const index = node.getFullStart();
        const length = node.getFullWidth();
        treeRecorder.remove(index, length);
    });
}
function removeFullLineFromExportDeclarationsByModuleName(sourceTsFile, treeRecorder, moduleNameString) {
    sourceTsFile.statements
        .filter((s) => ts.isExportDeclaration(s) &&
        s.moduleSpecifier &&
        ts.isStringLiteral(s.moduleSpecifier) &&
        s.moduleSpecifier.text === moduleNameString)
        .forEach((node) => {
        const index = node.getFullStart();
        const length = node.getFullWidth();
        treeRecorder.remove(index, length);
    });
}
function removeFullLineWithCallExpressionByModuleName(sourceTsFile, treeRecorder, moduleCallExpression) {
    sourceTsFile.statements
        .filter((s) => ts.isVariableStatement(s) &&
        ts.isVariableDeclarationList(s.declarationList) &&
        s.declarationList.declarations.length === 1 &&
        !!s.declarationList.declarations[0].initializer &&
        s.declarationList.declarations[0].initializer
            .getText()
            .indexOf(moduleCallExpression) !== -1)
        .forEach((node) => {
        const index = node.getFullStart();
        const length = node.getFullWidth();
        treeRecorder.remove(index, length);
    });
}
//# sourceMappingURL=ssr.js.map
"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@angular-devkit/core");
const schematics_1 = require("@angular-devkit/schematics");
const schematics_2 = require("@angular/cdk/schematics");
const compiler_1 = require("@angular/compiler");
const ast_utils_1 = require("@schematics/angular/utility/ast-utils");
const change_1 = require("@schematics/angular/utility/change");
const ts = __importStar(require("typescript"));
const constants_1 = require("../constants");
var InsertDirection;
(function (InsertDirection) {
    InsertDirection[InsertDirection["LEFT"] = 0] = "LEFT";
    InsertDirection[InsertDirection["RIGHT"] = 1] = "RIGHT";
})(InsertDirection = exports.InsertDirection || (exports.InsertDirection = {}));
function getTsSourceFile(tree, path) {
    const buffer = tree.read(path);
    if (!buffer) {
        throw new schematics_1.SchematicsException(`Could not read file (${path}).`);
    }
    const content = buffer.toString(constants_1.UTF_8);
    const source = ts.createSourceFile(path, content, ts.ScriptTarget.Latest, true);
    return source;
}
exports.getTsSourceFile = getTsSourceFile;
function getAllTsSourceFiles(tree, basePath) {
    const results = [];
    tree.getDir(basePath).visit((filePath) => {
        if (filePath.endsWith('.ts')) {
            results.push(filePath);
        }
    });
    return results.map((f) => getTsSourceFile(tree, f));
}
exports.getAllTsSourceFiles = getAllTsSourceFiles;
function getIndexHtmlPath(project) {
    const buildOptions = schematics_2.getProjectTargetOptions(project, 'build');
    if (!buildOptions.index) {
        throw new schematics_1.SchematicsException('"index.html" file not found.');
    }
    return buildOptions.index;
}
exports.getIndexHtmlPath = getIndexHtmlPath;
function getPathResultsForFile(tree, file, directory) {
    const results = [];
    const dir = directory || '/';
    tree.getDir(dir).visit((filePath) => {
        if (filePath.endsWith(file)) {
            results.push(filePath);
        }
    });
    return results;
}
exports.getPathResultsForFile = getPathResultsForFile;
function getHtmlFiles(tree, fileName = '.html', directory) {
    return getPathResultsForFile(tree, fileName || '.html', directory);
}
exports.getHtmlFiles = getHtmlFiles;
function insertComponentSelectorComment(content, componentSelector, componentProperty) {
    const selector = buildSelector(componentSelector);
    const comment = buildHtmlComment(componentProperty.comment);
    let index = 0;
    let newContent = content;
    while (true) {
        index = getTextPosition(newContent, selector, index);
        if (index == null) {
            break;
        }
        newContent = newContent.slice(0, index) + comment + newContent.slice(index);
        index += comment.length + componentSelector.length;
    }
    return newContent;
}
exports.insertComponentSelectorComment = insertComponentSelectorComment;
function getTextPosition(content, text, startingPosition = 0) {
    const index = content.indexOf(text, startingPosition);
    return index !== -1 ? index : undefined;
}
function buildSelector(selector) {
    return `<${selector}`;
}
function visitHtmlNodesRecursively(nodes, propertyName, resultingElements = [], parentElement) {
    nodes.forEach((node) => {
        if (node instanceof compiler_1.Attribute && parentElement) {
            if (node.name.includes(propertyName) ||
                node.value.includes(propertyName)) {
                resultingElements.push(parentElement);
            }
        }
        if (node instanceof compiler_1.Element) {
            visitHtmlNodesRecursively(node.attrs, propertyName, resultingElements, node);
            visitHtmlNodesRecursively(node.children, propertyName, resultingElements, node);
        }
    });
}
function insertHtmlComment(content, componentProperty) {
    const comment = buildHtmlComment(componentProperty.comment);
    const result = new compiler_1.HtmlParser().parse(content, '');
    const resultingElements = [];
    visitHtmlNodesRecursively(result.rootNodes, componentProperty.name, resultingElements);
    resultingElements
        .map((node) => node.sourceSpan.start.line)
        .forEach((line, i) => {
        const split = content.split('\n');
        split.splice(line + i, 0, comment);
        content = split.join('\n');
    });
    return content;
}
exports.insertHtmlComment = insertHtmlComment;
function buildHtmlComment(commentText) {
    return `<!-- ${commentText} -->`;
}
function commitChanges(host, path, changes, insertDirection = InsertDirection.RIGHT) {
    if (!changes || changes.length === 0) {
        return;
    }
    const recorder = host.beginUpdate(path);
    changes.forEach((change) => {
        if (change instanceof change_1.InsertChange) {
            const pos = change.pos;
            const toAdd = change.toAdd;
            if (insertDirection === InsertDirection.LEFT) {
                recorder.insertLeft(pos, toAdd);
            }
            else {
                recorder.insertRight(pos, toAdd);
            }
        }
        else if (change instanceof change_1.ReplaceChange) {
            const pos = change['pos'];
            const oldText = change['oldText'];
            const newText = change['newText'];
            recorder.remove(pos, oldText.length);
            if (insertDirection === InsertDirection.LEFT) {
                recorder.insertLeft(pos, newText);
            }
            else {
                recorder.insertRight(pos, newText);
            }
        }
        else if (change instanceof change_1.RemoveChange) {
            const pos = change['pos'];
            const length = change['toRemove'].length;
            recorder.remove(pos, length);
        }
    });
    host.commitUpdate(recorder);
}
exports.commitChanges = commitChanges;
function findConstructor(nodes) {
    return nodes.find((n) => n.kind === ts.SyntaxKind.Constructor);
}
exports.findConstructor = findConstructor;
function defineProperty(nodes, path, toAdd) {
    const constructorNode = findConstructor(nodes);
    if (!constructorNode) {
        throw new schematics_1.SchematicsException(`No constructor found in ${path}.`);
    }
    return new change_1.InsertChange(path, constructorNode.pos + 1, toAdd);
}
exports.defineProperty = defineProperty;
/**
 *
 * Method performs the following checks on the provided `source` file:
 * - is the file inheriting the provided `constructorDeprecation.class`
 * - is the `constructorDeprecation.class` imported from the specified `constructorDeprecation.importPath`
 * - is the file importing all the provided `parameterClassTypes` from the expected import path
 * - does the provided file contain a constructor
 * - does the `super()` call exist in the constructor
 * - does the param number passed to `super()` match the expected number
 * - does the order and the type of the constructor parameters match the expected `parameterClassTypes`
 *
 * If only once condition is not satisfied, the method returns `false`. Otherwise, it returns `true`.
 *
 * @param source a ts source file
 * @param inheritedClass a class which customers might have extended
 * @param parameterClassTypes a list of parameter class types. Must be provided in the order in which they appear in the deprecated constructor.
 */
function isCandidateForConstructorDeprecation(source, constructorDeprecation) {
    const nodes = ast_utils_1.getSourceNodes(source);
    if (!isInheriting(nodes, constructorDeprecation.class)) {
        return false;
    }
    if (!ast_utils_1.isImported(source, constructorDeprecation.class, constructorDeprecation.importPath)) {
        return false;
    }
    if (!checkImports(source, constructorDeprecation.deprecatedParams)) {
        return false;
    }
    const constructorNode = findConstructor(nodes);
    if (!constructorNode) {
        return false;
    }
    if (!checkConstructorParameters(constructorNode, constructorDeprecation.deprecatedParams)) {
        return false;
    }
    if (!checkSuper(constructorNode, constructorDeprecation.deprecatedParams)) {
        return false;
    }
    return true;
}
exports.isCandidateForConstructorDeprecation = isCandidateForConstructorDeprecation;
function isInheriting(nodes, inheritedClass) {
    const heritageClauseNodes = nodes.filter((node) => node.kind === ts.SyntaxKind.HeritageClause);
    const heritageNodes = findMultiLevelNodesByTextAndKind(heritageClauseNodes, inheritedClass, ts.SyntaxKind.Identifier);
    return heritageNodes.length !== 0;
}
exports.isInheriting = isInheriting;
function checkImports(source, parameterClassTypes) {
    for (const classImport of parameterClassTypes) {
        if (!ast_utils_1.isImported(source, classImport.className, classImport.importPath)) {
            return false;
        }
    }
    return true;
}
function checkConstructorParameters(constructorNode, parameterClassTypes) {
    const constructorParameters = ast_utils_1.findNodes(constructorNode, ts.SyntaxKind.Parameter);
    const foundClassTypes = [];
    for (const parameterClassType of parameterClassTypes) {
        for (const constructorParameter of constructorParameters) {
            const constructorParameterType = ast_utils_1.findNodes(constructorParameter, ts.SyntaxKind.Identifier).filter((node) => node.getText() === parameterClassType.className);
            if (constructorParameterType.length !== 0) {
                foundClassTypes.push(parameterClassType);
            }
        }
    }
    return foundClassTypes.length === parameterClassTypes.length;
}
function isInjected(constructorNode, parameterClassType) {
    const constructorParameters = ast_utils_1.findNodes(constructorNode, ts.SyntaxKind.Parameter);
    for (const constructorParameter of constructorParameters) {
        const constructorParameterType = ast_utils_1.findNodes(constructorParameter, ts.SyntaxKind.Identifier).filter((node) => node.getText() === parameterClassType.className);
        if (constructorParameterType.length > 0) {
            return true;
        }
    }
    return false;
}
function checkSuper(constructorNode, parameterClassTypes) {
    const constructorBlock = ast_utils_1.findNodes(constructorNode, ts.SyntaxKind.Block)[0];
    const callExpressions = ast_utils_1.findNodes(constructorBlock, ts.SyntaxKind.CallExpression);
    if (callExpressions.length === 0) {
        return false;
    }
    // super has to be the first expression in constructor
    const firstCallExpression = callExpressions[0];
    const superKeyword = ast_utils_1.findNodes(firstCallExpression, ts.SyntaxKind.SuperKeyword);
    if (superKeyword && superKeyword.length === 0) {
        return false;
    }
    const params = ast_utils_1.findNodes(firstCallExpression, ts.SyntaxKind.Identifier);
    if (params.length !== parameterClassTypes.length) {
        return false;
    }
    return true;
}
function addConstructorParam(source, sourcePath, constructorNode, paramToAdd) {
    if (!constructorNode) {
        throw new schematics_1.SchematicsException(`No constructor found in ${sourcePath}.`);
    }
    const changes = [];
    if (!isInjected(constructorNode, paramToAdd)) {
        changes.push(injectService(constructorNode, sourcePath, paramToAdd.className, 'no-modifier'));
    }
    if (!ast_utils_1.isImported(source, paramToAdd.className, paramToAdd.importPath)) {
        changes.push(ast_utils_1.insertImport(source, sourcePath, paramToAdd.className, paramToAdd.importPath));
    }
    const paramName = getParamName(source, constructorNode, paramToAdd);
    changes.push(updateConstructorSuperNode(sourcePath, constructorNode, paramName || paramToAdd.className));
    return changes;
}
exports.addConstructorParam = addConstructorParam;
function removeConstructorParam(source, sourcePath, constructorNode, paramToRemove) {
    if (!constructorNode) {
        throw new schematics_1.SchematicsException(`No constructor found in ${sourcePath}.`);
    }
    const changes = [];
    if (shouldRemoveImportAndParam(source, paramToRemove)) {
        const importRemovalChange = removeImport(source, sourcePath, paramToRemove);
        const constructorParamRemovalChanges = removeConstructorParamInternal(sourcePath, constructorNode, paramToRemove);
        changes.push(importRemovalChange, ...constructorParamRemovalChanges);
    }
    const paramName = getParamName(source, constructorNode, paramToRemove);
    if (!paramName) {
        return [new change_1.NoopChange()];
    }
    const superRemoval = removeParamFromSuper(sourcePath, constructorNode, paramName);
    changes.push(...superRemoval);
    return changes;
}
exports.removeConstructorParam = removeConstructorParam;
function getParamName(source, constructorNode, classType) {
    const nodes = ast_utils_1.getSourceNodes(source);
    const constructorParameters = ast_utils_1.findNodes(constructorNode, ts.SyntaxKind.Parameter);
    const classDeclarationNode = nodes.find((node) => node.kind === ts.SyntaxKind.ClassDeclaration);
    if (!classDeclarationNode) {
        return undefined;
    }
    for (const constructorParameter of constructorParameters) {
        if (constructorParameter.getText().includes(classType.className)) {
            const paramVariableNode = constructorParameter
                .getChildren()
                .find((node) => node.kind === ts.SyntaxKind.Identifier);
            const paramName = paramVariableNode
                ? paramVariableNode.getText()
                : undefined;
            return paramName;
        }
    }
    return undefined;
}
function shouldRemoveImportAndParam(source, importToRemove) {
    const nodes = ast_utils_1.getSourceNodes(source);
    const constructorNode = findConstructor(nodes);
    if (!constructorNode) {
        return true;
    }
    const classDeclarationNode = nodes.find((node) => node.kind === ts.SyntaxKind.ClassDeclaration);
    if (!classDeclarationNode) {
        return true;
    }
    const constructorParameters = getConstructorParameterList(constructorNode);
    for (const constructorParameter of constructorParameters) {
        if (constructorParameter.getText().includes(importToRemove.className)) {
            const paramVariableNode = constructorParameter
                .getChildren()
                .find((node) => node.kind === ts.SyntaxKind.Identifier);
            const paramName = paramVariableNode ? paramVariableNode.getText() : '';
            const paramUsages = ast_utils_1.findNodes(classDeclarationNode, ts.SyntaxKind.Identifier).filter((node) => node.getText() === paramName);
            // if there are more than two usages (injection and passing to super), then the param is used elsewhere in the class
            if (paramUsages.length > 2) {
                return false;
            }
            return true;
        }
    }
    return true;
}
function removeImport(source, sourcePath, importToRemove) {
    const importDeclarationNode = getImportDeclarationNode(source, importToRemove);
    if (!importDeclarationNode) {
        return new change_1.NoopChange();
    }
    let position;
    let toRemove = importToRemove.className;
    const importSpecifierNodes = ast_utils_1.findNodes(importDeclarationNode, ts.SyntaxKind.ImportSpecifier);
    if (importSpecifierNodes.length === 1) {
        // delete the whole import line
        position = importDeclarationNode.getStart();
        toRemove = importDeclarationNode.getText();
    }
    else {
        // delete only the specified import, and leave the rest
        const importSpecifier = importSpecifierNodes
            .map((node, i) => {
            const importNode = ast_utils_1.findNode(node, ts.SyntaxKind.Identifier, importToRemove.className);
            return {
                importNode,
                i,
            };
        })
            .filter((result) => result.importNode)[0];
        if (!importSpecifier.importNode) {
            return new change_1.NoopChange();
        }
        // in case the import that needs to be removed is in the middle, we need to remove the ',' that follows the found import
        if (importSpecifier.i !== importSpecifierNodes.length - 1) {
            toRemove += ',';
        }
        position = importSpecifier.importNode.getStart();
    }
    return new change_1.RemoveChange(sourcePath, position, toRemove);
}
function getImportDeclarationNode(source, importToCheck) {
    // collect al the import declarations
    const importDeclarationNodes = getImportDeclarations(source, importToCheck.importPath);
    if (importDeclarationNodes.length === 0) {
        return undefined;
    }
    // find the one that contains the specified `importToCheck.className`
    let importDeclarationNode = importDeclarationNodes[0];
    for (const currentImportDeclaration of importDeclarationNodes) {
        const importIdentifiers = ast_utils_1.findNodes(currentImportDeclaration, ts.SyntaxKind.Identifier);
        const found = importIdentifiers.find((node) => node.getText() === importToCheck.className);
        if (found) {
            importDeclarationNode = currentImportDeclaration;
            break;
        }
    }
    return importDeclarationNode;
}
function getConstructorParameterList(constructorNode) {
    const syntaxList = constructorNode
        .getChildren()
        .filter((node) => node.kind === ts.SyntaxKind.SyntaxList)[0];
    return ast_utils_1.findNodes(syntaxList, ts.SyntaxKind.Parameter);
}
function removeConstructorParamInternal(sourcePath, constructorNode, importToRemove) {
    const constructorParameters = getConstructorParameterList(constructorNode);
    for (let i = 0; i < constructorParameters.length; i++) {
        const constructorParameter = constructorParameters[i];
        if (constructorParameter.getText().includes(importToRemove.className)) {
            const changes = [];
            // if it's not the first parameter that should be removed, we should remove the comma after the previous parameter
            if (i !== 0) {
                const previousParameter = constructorParameters[i - 1];
                changes.push(new change_1.RemoveChange(sourcePath, previousParameter.end, ','));
                // if removing the first param, cleanup the comma after it
            }
            else if (i === 0 && constructorParameters.length > 1) {
                const commas = ast_utils_1.findNodes(constructorNode, ts.SyntaxKind.CommaToken);
                // get the comma that matches the constructor parameter's position
                const comma = commas[i];
                changes.push(new change_1.RemoveChange(sourcePath, comma.getStart(), ','));
            }
            changes.push(new change_1.RemoveChange(sourcePath, constructorParameter.getStart(), constructorParameter.getText()));
            return changes;
        }
    }
    return [];
}
function removeParamFromSuper(sourcePath, constructorNode, paramName) {
    const constructorBlock = ast_utils_1.findNodes(constructorNode, ts.SyntaxKind.Block)[0];
    const callExpressions = ast_utils_1.findNodes(constructorBlock, ts.SyntaxKind.CallExpression);
    if (callExpressions.length === 0) {
        throw new schematics_1.SchematicsException('No super() call found.');
    }
    const changes = [];
    // `super()` has to be the first expression in constructor
    const firstCallExpression = callExpressions[0];
    const params = ast_utils_1.findNodes(firstCallExpression, ts.SyntaxKind.Identifier);
    const commas = ast_utils_1.findNodes(firstCallExpression, ts.SyntaxKind.CommaToken);
    for (let i = 0; i < params.length; i++) {
        const param = params[i];
        if (param.getText() === paramName) {
            if (i !== 0) {
                const previousCommaPosition = commas[i - 1].getStart();
                changes.push(new change_1.RemoveChange(sourcePath, previousCommaPosition, ','));
                // if removing the first param, cleanup the comma after it
            }
            else if (i === 0 && params.length > 0) {
                // get the comma that matches the constructor parameter's position
                const comma = commas[i];
                changes.push(new change_1.RemoveChange(sourcePath, comma.getStart(), ','));
            }
            changes.push(new change_1.RemoveChange(sourcePath, param.getStart(), paramName));
            break;
        }
    }
    return changes;
}
function updateConstructorSuperNode(sourcePath, constructorNode, propertyName) {
    const callExpressions = ast_utils_1.findNodes(constructorNode, ts.SyntaxKind.CallExpression);
    propertyName = core_1.strings.camelize(propertyName);
    if (callExpressions.length === 0) {
        throw new schematics_1.SchematicsException('No super() call found.');
    }
    // super has to be the first expression in constructor
    const firstCallExpression = callExpressions[0];
    const superKeyword = ast_utils_1.findNodes(firstCallExpression, ts.SyntaxKind.SuperKeyword);
    if (superKeyword && superKeyword.length === 0) {
        throw new schematics_1.SchematicsException('No super() call found.');
    }
    let toInsert = '';
    let position;
    const params = ast_utils_1.findNodes(firstCallExpression, ts.SyntaxKind.Identifier);
    // just an empty super() call, without any params passed to it
    if (params.length === 0) {
        position = superKeyword[0].end + 1;
    }
    else {
        const lastParam = params[params.length - 1];
        toInsert += ', ';
        position = lastParam.end;
    }
    toInsert += propertyName;
    return new change_1.InsertChange(sourcePath, position, toInsert);
}
function injectService(constructorNode, path, serviceName, modifier, propertyName) {
    if (!constructorNode) {
        throw new schematics_1.SchematicsException(`No constructor found in ${path}.`);
    }
    const constructorParameters = getConstructorParameterList(constructorNode);
    let toInsert = '';
    let position = constructorNode.getStart() + 'constructor('.length;
    if (constructorParameters.length > 0) {
        toInsert += ', ';
        const lastParam = constructorParameters[constructorParameters.length - 1];
        position = lastParam.end;
    }
    propertyName = propertyName
        ? core_1.strings.camelize(propertyName)
        : core_1.strings.camelize(serviceName);
    if (modifier !== 'no-modifier')
        toInsert += `${modifier} `;
    toInsert += `${propertyName}: ${core_1.strings.classify(serviceName)}`;
    return new change_1.InsertChange(path, position, toInsert);
}
exports.injectService = injectService;
function buildSpartacusComment(comment) {
    return `// ${constants_1.TODO_SPARTACUS} ${comment}\n`;
}
exports.buildSpartacusComment = buildSpartacusComment;
function insertCommentAboveConfigProperty(sourcePath, source, identifierName, comment) {
    const identifierNodes = new Set();
    ast_utils_1.getSourceNodes(source)
        .filter((node) => node.kind === ts.SyntaxKind.ObjectLiteralExpression)
        .forEach((objectLiteralNode) => ast_utils_1.findNodes(objectLiteralNode, ts.SyntaxKind.Identifier)
        .filter((node) => node.getText() === identifierName)
        .forEach((idNode) => identifierNodes.add(idNode)));
    const changes = [];
    identifierNodes.forEach((n) => changes.push(new change_1.InsertChange(sourcePath, getLineStartFromTSFile(source, n.getStart()), `${comment}`)));
    return changes;
}
exports.insertCommentAboveConfigProperty = insertCommentAboveConfigProperty;
function insertCommentAboveIdentifier(sourcePath, source, identifierName, comment, identifierType = ts.SyntaxKind.Identifier) {
    const classNode = ast_utils_1.getSourceNodes(source).find((node) => node.kind === ts.SyntaxKind.ClassDeclaration);
    if (!classNode) {
        return [new change_1.NoopChange()];
    }
    const identifierNodes = ast_utils_1.findNodes(classNode, identifierType).filter((node) => node.getText() === identifierName);
    const changes = [];
    identifierNodes.forEach((n) => changes.push(new change_1.InsertChange(sourcePath, getLineStartFromTSFile(source, n.getStart()), `${comment}`)));
    return changes;
}
exports.insertCommentAboveIdentifier = insertCommentAboveIdentifier;
function getImportDeclarations(source, importPath) {
    const imports = ast_utils_1.getSourceNodes(source).filter((node) => node.kind === ts.SyntaxKind.ImportDeclaration);
    return imports.filter((imp) => imp.moduleSpecifier
        .getText()
        .includes(importPath));
}
function filterNamespacedImports(imports) {
    return imports
        .filter((imp) => { var _a, _b; return (_b = (_a = imp.importClause) === null || _a === void 0 ? void 0 : _a.namedBindings) === null || _b === void 0 ? void 0 : _b.name; })
        .filter(Boolean);
}
function filterNamedImports(imports) {
    return imports
        .filter((imp) => { var _a, _b; return (_b = (_a = imp.importClause) === null || _a === void 0 ? void 0 : _a.namedBindings) === null || _b === void 0 ? void 0 : _b.elements; })
        .filter(Boolean);
}
function insertCommentAboveImportIdentifier(sourcePath, source, identifierName, importPath, comment) {
    const imports = getImportDeclarations(source, importPath);
    const namedImports = filterNamedImports(imports);
    const namespacedImports = filterNamespacedImports(imports);
    const namespacedIdentifiers = namespacedImports
        .map((imp) => { var _a, _b, _c; return (_c = (_b = (_a = imp.importClause) === null || _a === void 0 ? void 0 : _a.namedBindings) === null || _b === void 0 ? void 0 : _b.name) === null || _c === void 0 ? void 0 : _c.escapedText; })
        .filter(Boolean);
    const namedImportsWithIdentifierName = namedImports.filter((imp) => ast_utils_1.findNodes(imp, ts.SyntaxKind.ImportSpecifier).find((node) => node.name.escapedText === identifierName));
    const propertyAccessExpressions = ast_utils_1.getSourceNodes(source).filter((node) => node.kind === ts.SyntaxKind.PropertyAccessExpression);
    const accessPropertiesToIdentifierName = propertyAccessExpressions
        .filter((member) => { var _a, _b; return namespacedIdentifiers.includes((_b = (_a = member) === null || _a === void 0 ? void 0 : _a.expression) === null || _b === void 0 ? void 0 : _b.escapedText); })
        .filter((member) => { var _a, _b; return identifierName === ((_b = (_a = member) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.escapedText); })
        .filter(Boolean);
    const changes = [];
    namedImportsWithIdentifierName.forEach((n) => changes.push(new change_1.InsertChange(sourcePath, getLineStartFromTSFile(source, n.getStart()), comment)));
    accessPropertiesToIdentifierName.forEach((n) => changes.push(new change_1.InsertChange(sourcePath, getLineStartFromTSFile(source, n.getStart()), comment)));
    return changes;
}
exports.insertCommentAboveImportIdentifier = insertCommentAboveImportIdentifier;
function renameIdentifierNode(sourcePath, source, oldName, newName) {
    const identifierNodes = findLevel1NodesInSourceByTextAndKind(source, oldName, ts.SyntaxKind.Identifier);
    const changes = [];
    identifierNodes.forEach((n) => changes.push(new change_1.ReplaceChange(sourcePath, n.getStart(), oldName, newName)));
    return changes;
}
exports.renameIdentifierNode = renameIdentifierNode;
function findLevel1NodesInSourceByTextAndKind(source, text, syntaxKind) {
    const nodes = ast_utils_1.getSourceNodes(source);
    return findLevel1NodesByTextAndKind(nodes, text, syntaxKind);
}
function findLevel1NodesByTextAndKind(nodes, text, syntaxKind) {
    return nodes
        .filter((n) => n.kind === syntaxKind)
        .filter((n) => n.getText() === text);
}
function findMultiLevelNodesByTextAndKind(nodes, text, syntaxKind) {
    const result = [];
    for (const node of nodes) {
        result.push(...ast_utils_1.findNodes(node, syntaxKind).filter((n) => n.getText() === text));
    }
    return result;
}
function getLineStartFromTSFile(source, position) {
    const lac = source.getLineAndCharacterOfPosition(position);
    return source.getPositionOfLineAndCharacter(lac.line, 0);
}
// as this is copied from https://github.com/angular/angular-cli/blob/master/packages/schematics/angular/app-shell/index.ts#L211, no need to test Angular's code
function getMetadataProperty(metadata, propertyName) {
    const properties = metadata.properties;
    const property = properties
        .filter((prop) => prop.kind === ts.SyntaxKind.PropertyAssignment)
        .filter((prop) => {
        const name = prop.name;
        switch (name.kind) {
            case ts.SyntaxKind.Identifier:
                return name.getText() === propertyName;
            case ts.SyntaxKind.StringLiteral:
                return name.text === propertyName;
        }
        return false;
    })[0];
    return property;
}
exports.getMetadataProperty = getMetadataProperty;
function getLineFromTSFile(host, path, position) {
    const tsFile = getTsSourceFile(host, path);
    const lac = tsFile.getLineAndCharacterOfPosition(position);
    const lineStart = tsFile.getPositionOfLineAndCharacter(lac.line, 0);
    const nextLineStart = tsFile.getPositionOfLineAndCharacter(lac.line + 1, 0);
    return [lineStart, nextLineStart - lineStart];
}
exports.getLineFromTSFile = getLineFromTSFile;
//# sourceMappingURL=file-utils.js.map
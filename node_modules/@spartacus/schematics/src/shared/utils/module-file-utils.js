"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@angular-devkit/core");
const schematics_1 = require("@angular/cdk/schematics");
const ast_utils_1 = require("@schematics/angular/utility/ast-utils");
const ts = __importStar(require("typescript"));
const constants_1 = require("../constants");
const file_utils_1 = require("./file-utils");
function stripTsFromImport(importPath) {
    if (!importPath.endsWith('.ts')) {
        return importPath;
    }
    return importPath.slice(0, importPath.length - 3);
}
exports.stripTsFromImport = stripTsFromImport;
function addImport(host, filePath, importText, importPath) {
    const moduleSource = file_utils_1.getTsSourceFile(host, filePath);
    if (!ast_utils_1.isImported(moduleSource, importText, importPath)) {
        const change = ast_utils_1.insertImport(moduleSource, filePath, importText, importPath);
        file_utils_1.commitChanges(host, filePath, [change], file_utils_1.InsertDirection.LEFT);
    }
}
exports.addImport = addImport;
function addToModuleImports(host, modulePath, importText, moduleSource) {
    return addToMetadata(host, modulePath, importText, 'imports', moduleSource);
}
exports.addToModuleImports = addToModuleImports;
function addToModuleDeclarations(host, modulePath, importText, moduleSource) {
    return addToMetadata(host, modulePath, importText, 'declarations', moduleSource);
}
exports.addToModuleDeclarations = addToModuleDeclarations;
function addToModuleEntryComponents(host, modulePath, importText, moduleSource) {
    return addToMetadata(host, modulePath, importText, 'entryComponents', moduleSource);
}
exports.addToModuleEntryComponents = addToModuleEntryComponents;
function addToModuleExports(host, modulePath, importText, moduleSource) {
    return addToMetadata(host, modulePath, importText, 'exports', moduleSource);
}
exports.addToModuleExports = addToModuleExports;
function addToMetadata(host, modulePath, importText, metadataType, moduleSource) {
    moduleSource = moduleSource || file_utils_1.getTsSourceFile(host, modulePath);
    return ast_utils_1.addSymbolToNgModuleMetadata(moduleSource, modulePath, metadataType, importText);
}
function addToModuleImportsAndCommitChanges(host, modulePath, importText) {
    const metadataChanges = addToModuleImports(host, modulePath, importText);
    file_utils_1.commitChanges(host, modulePath, metadataChanges, file_utils_1.InsertDirection.RIGHT);
}
exports.addToModuleImportsAndCommitChanges = addToModuleImportsAndCommitChanges;
// as this is copied from angular source, no need to test it
/**
 * Build a relative path from one file path to another file path.
 */
function buildRelativePath(from, to) {
    from = core_1.normalize(from);
    to = core_1.normalize(to);
    // Convert to arrays.
    const fromParts = from.split('/');
    const toParts = to.split('/');
    // Remove file names (preserving destination)
    fromParts.pop();
    const toFileName = toParts.pop();
    const relativePath = core_1.relative(core_1.normalize(fromParts.join('/') || '/'), core_1.normalize(toParts.join('/') || '/'));
    let pathPrefix = '';
    // Set the path prefix for same dir or child dir, parent dir starts with `..`
    if (!relativePath) {
        pathPrefix = '.';
    }
    else if (!relativePath.startsWith('.')) {
        pathPrefix = `./`;
    }
    if (pathPrefix && !pathPrefix.endsWith('/')) {
        pathPrefix += '/';
    }
    return pathPrefix + (relativePath ? relativePath + '/' : '') + toFileName;
}
exports.buildRelativePath = buildRelativePath;
function getTemplateInfo(source) {
    const fileUrlResult = getTemplateUrlOrInlineTemplate(source, 'templateUrl');
    if (fileUrlResult) {
        return { templateUrl: fileUrlResult.contentOrUrl };
    }
    // if the 'templateUrl' is not specified, check for the inline template
    const inlineTemplateResult = getTemplateUrlOrInlineTemplate(source, 'template');
    if (inlineTemplateResult) {
        return {
            inlineTemplateContent: inlineTemplateResult.contentOrUrl,
            inlineTemplateStart: inlineTemplateResult.start,
        };
    }
    return undefined;
}
exports.getTemplateInfo = getTemplateInfo;
function getTemplateUrlOrInlineTemplate(source, templateOrTemplateUrl) {
    const decorator = ast_utils_1.getDecoratorMetadata(source, 'Component', constants_1.ANGULAR_CORE)[0];
    if (!decorator) {
        return undefined;
    }
    const templateMetadata = file_utils_1.getMetadataProperty(decorator, templateOrTemplateUrl);
    if (!templateMetadata) {
        return undefined;
    }
    let stringNode;
    stringNode = stringNode = schematics_1.findNodes(templateMetadata, ts.SyntaxKind.NoSubstitutionTemplateLiteral)[0];
    if (!stringNode) {
        // fallback to single/double quotes
        stringNode = schematics_1.findNodes(templateMetadata, ts.SyntaxKind.StringLiteral)[0];
    }
    if (!stringNode) {
        return undefined;
    }
    const result = stringNode.text.trim();
    if (templateOrTemplateUrl === 'templateUrl') {
        const url = result.replace('./', '');
        return { contentOrUrl: url };
    }
    return {
        contentOrUrl: result,
        start: stringNode.getStart() + 1,
    };
}
//# sourceMappingURL=module-file-utils.js.map
{"version":3,"file":"lock-focus.directive.d.ts","sources":["lock-focus.directive.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { AfterViewInit, ElementRef, EventEmitter, OnInit, Renderer2 } from '@angular/core';\r\nimport { LockFocusConfig } from '../keyboard-focus.model';\r\nimport { TrapFocusDirective } from '../trap/trap-focus.directive';\r\nimport { LockFocusService } from './lock-focus.service';\r\n/**\r\n * Directive that adds persistence for focussed element in case\r\n * the elements are being rebuild. This happens often when change\r\n * detection kicks in because of new data set from the backend.\r\n */\r\nexport declare class LockFocusDirective extends TrapFocusDirective implements OnInit, AfterViewInit {\r\n    protected elementRef: ElementRef;\r\n    protected service: LockFocusService;\r\n    protected renderer: Renderer2;\r\n    protected defaultConfig: LockFocusConfig;\r\n    protected config: LockFocusConfig;\r\n    /**\r\n     * Indicates that the host is configured to use locking. This is available as a\r\n     * CSS class `focus-lock`.\r\n     */\r\n    shouldLock: boolean;\r\n    /**\r\n     * Indicates that the host is locked. This is available as a CSS class `is-locked`.\r\n     */\r\n    isLocked: boolean;\r\n    /**\r\n     * Emits an event when the host is unlocked.\r\n     */\r\n    unlock: EventEmitter<boolean>;\r\n    /**\r\n     * When the user selects enter or space, the focusable childs are\r\n     * unlocked, which means that the tabindex is set to 0.\r\n     */\r\n    handleEnter(event: KeyboardEvent): void;\r\n    /**\r\n     * In case any of the children elements is touched by the mouse,\r\n     * we unlock the group to not break the mouse-experience.\r\n     */\r\n    handleClick(event: UIEvent): void;\r\n    constructor(elementRef: ElementRef, service: LockFocusService, renderer: Renderer2);\r\n    protected lockFocus(): void;\r\n    protected unlockFocus(event?: UIEvent): void;\r\n    ngOnInit(): void;\r\n    ngAfterViewInit(): void;\r\n    handleFocus(event?: KeyboardEvent): void;\r\n    handleEscape(event: KeyboardEvent): void;\r\n    /**\r\n     * When the handleFocus is called without an actual event, it's coming from Autofocus.\r\n     * In this case we unlock the focusable children in case there's a focusable child that\r\n     * was unlocked before.\r\n     *\r\n     * We keep this private to not polute the API.\r\n     */\r\n    private shouldUnlockAfterAutofocus;\r\n    /**\r\n     * Add the tabindex attribute to the focusable children elements\r\n     */\r\n    protected addTabindexToChildren(i?: number): void;\r\n    /**\r\n     * Utility method, returns all focusable children for the host element.\r\n     *\r\n     * We keep this private to not polute the API.\r\n     */\r\n    private get hasFocusableChildren();\r\n    /**\r\n     * Returns the focusable children of the host element. If the host element\r\n     * is configured to be locked, the query is restricted to child elements\r\n     * with a tabindex !== `-1`.\r\n     *\r\n     * We keep this private to not polute the API.\r\n     */\r\n    private get focusable();\r\n}\r\n"]}